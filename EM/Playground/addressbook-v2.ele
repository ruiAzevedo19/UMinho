module addressBookV2
open util/ordering [Book]

abstract sig Target {}

sig Addr extends Target {}
abstract sig Name extends Target {}

sig Alias, Group extends Name {}
sig Book {names : set Name , addr : names -> some Target }
	      { 
	      		no n : Name | n in n.^addr  
			all a : Alias  | lone a.addr
	      }

pred add(b, b1 : Book , n : Name , t : Target){
	b1.addr = b.addr + n -> t
}

pred del(b, b1 : Book , n : Name , t : Target){
	b1.addr = b.addr - n -> t
}

fun lookup(b : Book , n : Name) : set Addr{
	n.^(b.addr) & Addr
}

assert lookupYields {
	all b : Book, n : b.names | some lookup[b,n]
}

assert delUndosAdd {
	all b, b1, b2 : Book , n : Name , t : Target |
		no n.(b.addr) and add[b,b1,n,t] and del[b1,b2,n,t] implies b.addr = b2.addr

}

assert addIdempotent {
	all b, b1, b2 : Book , n : Name , t : Target | 
		add[b,b1,n,t] and add[b1,b2,n,t] implies b1.addr = b2.addr
}

-- ordering
pred init (b: Book) { no b.addr }

fact traces {
	init[ first[] ]
	all b: Book - last[] | let b1= next[b] |
		some n: Name, t : Target | add[b, b1, n, t] or del [b, b1, n, t] 
}

pred show() {}
run show for 4

